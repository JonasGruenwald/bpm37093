<!DOCTYPE html>
<!-- 
Proof of concept of 3D star visualization using orthographic projection on HTML5 Canvas
(straight from the slop machine)
-->
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Star Projection Demo</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #000;
      color: #0ff;
      font-family: monospace;
      overflow: hidden;
    }

    canvas {
      display: block;
      cursor: grab;
    }

    canvas:active {
      cursor: grabbing;
    }

    #info {
      position: absolute;
      top: 20px;
      left: 20px;
      font-size: 12px;
      line-height: 1.5;
    }
  </style>
</head>

<body>
  <div id="info">
    3D Star Field Visualization<br>
    Drag to rotate | Scroll to zoom
  </div>
  <canvas id="canvas"></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // Set canvas size to window size
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Camera and rotation
    let angleX = 0.3;
    let angleY = 0.3;
    let angleZ = 0;
    let zoom = 500;
    let isDragging = false;
    let lastX = 0;
    let lastY = 0;

    // Stars will be loaded from JSON
    let stars = [];

    // Load star data
    fetch('./data/brightest_stars_50ly.json')
      .then(response => response.json())
      .then(data => {
        stars = data.map(star => ({
          x: star.x * 7.5,
          y: star.y * 7.5,
          z: star.z * 7.5,
          label: star.full_name ?? star.name,
          showLabel: true,
          brightness: Math.max(0.3, 1 - (star.visual_magnitude + 2) / 10), // Brighter stars have lower magnitude
          size: Math.max(1, 3 - star.visual_magnitude / 2) // Brighter = larger
        })).filter(s => !s.label.includes("*"));
        console.log(`Loaded ${stars.length} stars`);
      })
      .catch(error => {
        console.error('Error loading star data:', error);
      });

    // 3D rotation matrices
    function rotateX(point, angle) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      return {
        x: point.x,
        y: point.y * cos - point.z * sin,
        z: point.y * sin + point.z * cos
      };
    }

    function rotateY(point, angle) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      return {
        x: point.x * cos + point.z * sin,
        y: point.y,
        z: -point.x * sin + point.z * cos
      };
    }

    function rotateZ(point, angle) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      return {
        x: point.x * cos - point.y * sin,
        y: point.x * sin + point.y * cos,
        z: point.z
      };
    }

    // Orthographic projection
    function project(point3d) {
      // Apply rotations
      let p = rotateY(point3d, angleY);
      p = rotateX(p, angleX);
      p = rotateZ(p, angleZ);

      // Orthographic projection (just use x and y, ignore z for position)
      const scale = zoom / 400;
      return {
        x: canvas.width / 2 + p.x * scale,
        y: canvas.height / 2 - p.y * scale,
        z: p.z // Keep z for depth sorting
      };
    }

    // Draw grid lines
    function drawGrid() {
      ctx.strokeStyle = 'rgba(0, 100, 150, 0.3)';
      ctx.lineWidth = 0.5;

      const gridSize = 400;
      const gridSpacing = 50;

      // Draw grid lines in XZ plane (horizontal plane)
      for (let i = -gridSize; i <= gridSize; i += gridSpacing) {
        const p1 = project({ x: i, y: 0, z: -gridSize });
        const p2 = project({ x: i, y: 0, z: gridSize });

        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();

        const p3 = project({ x: -gridSize, y: 0, z: i });
        const p4 = project({ x: gridSize, y: 0, z: i });

        ctx.beginPath();
        ctx.moveTo(p3.x, p3.y);
        ctx.lineTo(p4.x, p4.y);
        ctx.stroke();
      }
    }

    // Draw orbital circles as ellipses (efficient for orthographic projection)
    function drawOrbits() {
      ctx.strokeStyle = 'rgba(0, 150, 200, 0.4)';
      ctx.lineWidth = 2;

      const orbits = [100, 200, 300];

      orbits.forEach(radius => {
        // For a circle in the XZ plane viewed orthographically:
        // - Y-rotation just spins the circle but doesn't change its appearance
        // - X-rotation (pitch) squashes it vertically
        // - The ellipse always has horizontal radius = radius, vertical radius = radius * sin(angleX)

        const center = project({ x: 0, y: 0, z: 0 });

        // The horizontal extent is always the full radius (affected by zoom/scale)
        const scale = zoom / 400;
        const radiusX = radius * scale;

        // The vertical extent is squashed by sin(angleX)
        const radiusY = radius * scale * Math.sin(angleX);

        // No rotation needed - the ellipse is always axis-aligned
        ctx.beginPath();
        ctx.ellipse(center.x, center.y, radiusX, Math.abs(radiusY), 0, 0, Math.PI * 2);
        ctx.stroke();
      });
    }

    // Draw axes
    function drawAxes() {
      const axisLength = 400;

      // X axis (red)
      ctx.strokeStyle = 'rgba(255, 100, 100, 0.6)';
      ctx.lineWidth = 2;
      let p1 = project({ x: -axisLength, y: 0, z: 0 });
      let p2 = project({ x: axisLength, y: 0, z: 0 });
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();

      // Y axis (green) - vertical
      ctx.strokeStyle = 'rgba(100, 255, 100, 0.6)';
      p1 = project({ x: 0, y: -axisLength, z: 0 });
      p2 = project({ x: 0, y: axisLength, z: 0 });
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();

      // Z axis (blue)
      ctx.strokeStyle = 'rgba(100, 100, 255, 0.6)';
      p1 = project({ x: 0, y: 0, z: -axisLength });
      p2 = project({ x: 0, y: 0, z: axisLength });
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
    }

    // Draw center marker (Earth/Galactic center)
    function drawCenter() {
      const p = project({ x: 0, y: 0, z: 0 });

      // Draw crosshair
      ctx.strokeStyle = '#0ff';
      ctx.lineWidth = 2;
      const size = 10;

      ctx.beginPath();
      ctx.moveTo(p.x - size, p.y);
      ctx.lineTo(p.x + size, p.y);
      ctx.moveTo(p.x, p.y - size);
      ctx.lineTo(p.x, p.y + size);
      ctx.stroke();

      // Draw circle
      ctx.beginPath();
      ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
      ctx.stroke();

      // Label
      ctx.fillStyle = '#0ff';
      ctx.font = '12px monospace';
      ctx.fillText('Galactic Centre', p.x + 15, p.y + 5);
    }

    // Main render function
    function render() {
      // Clear canvas
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw background elements
      drawGrid();
      drawOrbits();
      drawAxes();

      // Sort stars by depth (z-coordinate) for proper rendering
      const projectedStars = stars.map(star => ({
        ...star,
        projected: project({ x: star.x, y: star.y, z: star.z })
      })).sort((a, b) => a.projected.z - b.projected.z);

      // Draw stars
      projectedStars.forEach(star => {
        const p = star.projected;

        // Draw star
        const alpha = star.brightness;
        // ctx.fillStyle = `rgba(0, 255, 255, ${alpha})`;
        ctx.fillStyle = `rgb(0, 255, 255)`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, star.size, 0, Math.PI * 2);
        ctx.fill();

        // Draw vertical line to horizontal plane (XZ plane at y=0)
        ctx.strokeStyle = `rgb(0, 255, 255)`;
        ctx.lineWidth = 0.5;
        const groundPoint = project({ x: star.x, y: 0, z: star.z });
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(groundPoint.x, groundPoint.y);
        ctx.stroke();

        // Draw label for some stars
        if (star.showLabel && star.label) {
          ctx.fillStyle = `rgb(0, 255, 255)`;
          ctx.font = '10px monospace';
          ctx.fillText(star.label, p.x + 5, p.y - 5);
        }
      });

      // Draw center last
      drawCenter();
    }

    // Animation loop
    function animate() {
      render();

      // Auto-rotate slowly
      if (!isDragging) {
        angleY += 0.0005;
      }

      requestAnimationFrame(animate);
    }

    // Mouse interaction
    canvas.addEventListener('mousedown', (e) => {
      isDragging = true;
      lastX = e.clientX;
      lastY = e.clientY;
    });

    canvas.addEventListener('mousemove', (e) => {
      if (isDragging) {
        const deltaX = e.clientX - lastX;
        const deltaY = e.clientY - lastY;

        angleY += deltaX * 0.005;
        angleX += deltaY * 0.005;

        lastX = e.clientX;
        lastY = e.clientY;
      }
    });

    canvas.addEventListener('mouseup', () => {
      isDragging = false;
    });

    canvas.addEventListener('mouseleave', () => {
      isDragging = false;
    });

    // Zoom with mouse wheel
    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      zoom += e.deltaY * -0.5;
      zoom = Math.max(50, Math.min(zoom, 800));
    });

    // Start animation
    animate();
  </script>
</body>

</html>